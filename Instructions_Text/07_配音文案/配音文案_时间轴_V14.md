# Sobel V14 配音文案 - 时间轴版本

**对应代码版本**：V14 (`sobel_v14_full.py`)  
**文档编号**：V14

## 时间计算说明

- **slow_wait(time)**: 实际等待时间 = time × 2.0
- **slow_play(animation, base_run_time)**: 实际动画时长 = base_run_time × 2.0
- **hud.show(text, wait_after)**: wait_after 是直接等待时间（不翻倍）
- **ask_question()**: 内部使用 slow_wait，等待时间翻倍

**时间格式**: `[场景开始时间] 累计时间 | 文案内容`

---

## Scene 0：直觉与混沌

**场景开始时间**: 0:00

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:00 | 0:00 | 如果让你画出这张图的轮廓，你会怎么画？ | 设问（ask_question，等待4秒） |
| 0:04 | 0:04 | 你的眼睛能自动忽略这些噪点，看见背后的线条。 | 人眼能力（等待1秒） |
| 0:05 | 0:05 | 但对于计算机来说，每一个噪点都是一次剧烈的数值跳变。 | 计算机困境（等待1秒） |
| 0:06 | 0:06 | 噪声掩盖了图像的结构。 | 噪声影响（等待1.2秒） |
| 0:07 | 0:07 | 机器如何区分'真正的边缘'和'随机的噪点'？ | 核心问题（等待1.5秒） |
| 0:09 | 0:09 | 这就是边缘检测的力量。 | 解决方案（等待1秒） |

**场景结束时间**: 约 0:10

---

## Scene 1：失去极限

**场景开始时间**: 0:10

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:10 | 0:10 | 在数学理想国，导数是切线的斜率。 | 数学理想（等待1秒） |
| 0:11 | 0:11 | 微积分告诉我们，导数就是斜率。但在像素世界里，我们遇到了一个物理屏障：像素是离散的。 | 像素世界困境（等待1.5秒） |
| 0:13 | 0:13 | 我们没有办法无限逼近，最小的步长就是 1。 | 步长限制（等待1秒） |
| 0:14 | 0:14 | 每个像素是一个桶，函数被量化成分段的近似。 | 像素量化（等待0.8秒） |
| 0:15 | 0:15 | 最小步长受限，Δx 无法继续变小。 | 步长受限（等待0.8秒） |
| 0:16 | 0:16 | 最小步长是 1 个像素，我们失去了极限。 | 失去极限（等待1.2秒） |
| 0:17 | 0:17 | 只能做割线估计，无法逼近真正的切线。 | 割线估计（等待1秒） |

**场景结束时间**: 约 0:18

---

## Scene 1.5：极限的困境

**场景开始时间**: 0:18

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:18 | 0:18 | 当微积分的'无限细分'撞上像素的'颗粒感'，导数还存在吗？ | 设问（等待3秒） |
| 0:21 | 0:21 | 斜率在收敛，但像素世界有硬约束。 | 收敛与约束（等待3秒） |
| 0:24 | 0:24 | 在数字图像里，Δx 最小就是 1 像素。 | 最小单位（等待3秒） |
| 0:27 | 0:27 | 结论：需要新的方法，在像素里重建导数。 | 结论（等待3秒） |

**场景结束时间**: 约 0:30

---

## Scene 2：泰勒抵消 → 中心差分

**场景开始时间**: 0:30

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:30 | 0:30 | 既然不能无限逼近，我们只能退而求其次：取相邻的点来估算。也就是'差分'。 | 差分引入（等待1.5秒） |
| 0:32 | 0:32 | 但直接相减会带来误差。 | 误差问题（等待1秒） |
| 0:33 | 0:33 | 前向与后向各有系统误差：奇偶阶项混在一起。 | 系统误差（等待1.5秒） |
| 0:35 | 0:35 | 这里有一个数学上的巧合：如果我们同时看左边一点和右边一点（泰勒展开）... | 数学巧合（等待1.5秒） |
| 0:37 | 0:37 | 你会发现，它们的误差恰好方向相反。 | 误差方向（等待1.5秒） |
| 0:39 | 0:39 | 如果我们把它们加起来……奇迹发生了，误差自我抵消了。 | 误差抵消（等待1.5秒） |
| 0:41 | 0:41 | 这就是中心差分，也是 Sobel 的一半灵魂。 | 中心差分（等待1.5秒） |

**场景结束时间**: 约 0:43

---

## Scene 2.5：差分对比

**场景开始时间**: 0:43

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:43 | 0:43 | 三种差分：前向、后向、中心 —— 谁的误差更小？ | 设问（等待1.5秒） |
| 0:45 | 0:45 | 中心差分利用两侧信息，误差阶更高。 | 中心差分优势（等待1.5秒） |
| 0:47 | 0:47 | 中心差分最"冷"，误差最低。 | 误差最低（等待1.2秒） |
| 0:48 | 0:48 | 结论：中心差分 = 低误差、对称采样。 | 结论（等待1.4秒） |

**场景结束时间**: 约 0:50

---

## Scene 3：Sobel 诞生

**场景开始时间**: 0:50

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 0:50 | 0:50 | 现在我们有了两个工具：一个是平滑（用来对付噪点），一个是中心差分（用来计算斜率）。 | 两个工具（等待1.5秒） |
| 0:52 | 0:52 | 直接微分会放大噪声。 | 直接微分问题（等待1秒） |
| 0:53 | 0:53 | 先平滑，再微分：用 [1,2,1]^T 做低通，再用 [-1,0,1] 做高通。 | 解决方案（等待1.5秒） |
| 0:55 | 0:55 | 平滑核滑过信号：窗口内的点被加权平均拉平。 | 平滑过程（等待1.2秒） |
| 0:56 | 0:56 | 平滑后，噪声被抑制，信号结构更清晰。 | 平滑效果（等待1.5秒） |
| 0:58 | 0:58 | Sobel 算子其实不是什么新发明，它只是把这两个动作，巧妙地打包进了一个 3x3 的小盒子里。 | Sobel 本质（等待1.5秒） |
| 1:00 | 1:00 | 一手按住噪点，一手提取边缘。 | Sobel 功能（等待2秒） |

**场景结束时间**: 约 1:02

---

## Scene 3.5：卷积可视化

**场景开始时间**: 1:02

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:02 | 1:02 | 卷积 = 滑动窗口的加权求和。看看 Sobel 如何工作。 | 卷积定义（等待1.5秒） |
| 1:04 | 1:04 | 窗口逐行扫描，每一步计算 G = 核 · 局部补丁。 | 扫描过程（等待1秒） |
| 1:05 | 1:05 | 卷积结果逐步填充：红=强边缘，蓝绿=弱。 | 结果填充（等待1.2秒） |

**场景结束时间**: 约 1:06

---

## Scene 4.2：多尺度边缘

**场景开始时间**: 1:06

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:06 | 1:06 | 尺度决定细节：小核抓细纹，大核抓粗轮廓。 | 尺度决定细节（等待1.5秒） |
| 1:08 | 1:08 | 3×3 抓细节，7×7 更平滑、边缘更粗。 | 不同尺度效果（等待1.4秒） |
| 1:09 | 1:09 | 融合多尺度：既留细节，也保轮廓。 | 多尺度融合（等待1.2秒） |

**场景结束时间**: 约 1:10

---

## Scene 4：3D 扫描

**场景开始时间**: 1:10

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:10 | 1:10 | 把亮度映射为高度，图像变成 3D 地形。 | 3D 映射（等待1.8秒） |
| 1:12 | 1:12 | 用滑动窗口扫描：窗口颜色随梯度大小而变。 | 扫描过程（等待1.8秒） |

**场景结束时间**: 约 1:14（注意：3D扫描动画较长，约12秒）

---

## Scene 4.6：真实图像处理

**场景开始时间**: 约 1:26（3D扫描结束后）

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:26 | 1:26 | 真实流程：原图 → 灰度 → Sobel X/Y → 梯度幅值 → 阈值。 | 处理流程（等待1.2秒） |
| 1:27 | 1:27 | 调阈值：过低=噪声，过高=断裂。 | 阈值调整（等待1.2秒） |

**场景结束时间**: 约 1:29

---

## Scene 4.5：应用对照

**场景开始时间**: 1:29

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:29 | 1:29 | 看看现实画面：左侧原图，右侧边缘提取。 | 现实画面（等待1.6秒） |
| 1:31 | 1:31 | Sobel 把结构凸显：道路边界、笔画、人脸轮廓、建筑窗格。 | 结构凸显（等待2秒） |

**场景结束时间**: 约 1:33

---

## Scene 5：总结与片尾

**场景开始时间**: 1:33

| 时间 | 累计时间 | 文案内容 | 备注 |
|------|---------|---------|------|
| 1:33 | 1:33 | 从连续导数到离散差分，从噪声到轮廓，我们看见了什么。 | 回顾（等待2秒） |
| 1:35 | 1:35 | 知行合一：数学理想 Δx→0，工程现实 pixel=1。 | 知行合一（等待2秒） |

**场景结束时间**: 约 1:37

---

## 总时长统计

- **Scene 0**: 约 10 秒
- **Scene 1**: 约 8 秒
- **Scene 1.5**: 约 12 秒
- **Scene 2**: 约 13 秒
- **Scene 2.5**: 约 7 秒
- **Scene 3**: 约 12 秒
- **Scene 3.5**: 约 4 秒
- **Scene 4.2**: 约 4 秒
- **Scene 4**: 约 16 秒（包含12秒3D扫描动画）
- **Scene 4.6**: 约 3 秒
- **Scene 4.5**: 约 4 秒
- **Scene 5**: 约 4 秒

**总时长**: 约 **97 秒**（1分37秒）

---

## 配音注意事项

1. **语速控制**：
   - 正常语速：每分钟约 200-250 字
   - 重要概念可适当放慢
   - 设问部分要有思考感

2. **情感表达**：
   - **设问部分**（0:00, 0:18, 0:43）：带有思考、探索的语气
   - **困境部分**（0:11, 0:32, 0:52）：带有困惑、挑战的语气
   - **解决部分**（0:35, 0:53, 0:58）：带有发现、惊喜的语气
   - **结论部分**（0:27, 0:48, 1:33）：带有总结、升华的语气

3. **停顿建议**：
   - 逗号：短暂停顿（0.3-0.5秒）
   - 句号：正常停顿（0.5-1秒）
   - 问号：较长停顿（1-1.5秒）
   - 省略号：思考停顿（1-2秒）

4. **重点强调词汇**：
   - "中心差分"、"Sobel"、"边缘检测"
   - "误差抵消"、"平滑"、"卷积"
   - "像素"、"离散"、"导数"

5. **时间容差**：
   - 实际配音时间可能与时间轴有 ±2-3 秒的偏差
   - 建议在关键时间点做标记，便于后期对齐

---

## 快速参考表（按时间顺序）

| 时间 | 文案 |
|------|------|
| 0:00 | 如果让你画出这张图的轮廓，你会怎么画？ |
| 0:04 | 你的眼睛能自动忽略这些噪点，看见背后的线条。 |
| 0:05 | 但对于计算机来说，每一个噪点都是一次剧烈的数值跳变。 |
| 0:06 | 噪声掩盖了图像的结构。 |
| 0:07 | 机器如何区分'真正的边缘'和'随机的噪点'？ |
| 0:09 | 这就是边缘检测的力量。 |
| 0:10 | 在数学理想国，导数是切线的斜率。 |
| 0:11 | 微积分告诉我们，导数就是斜率。但在像素世界里，我们遇到了一个物理屏障：像素是离散的。 |
| 0:13 | 我们没有办法无限逼近，最小的步长就是 1。 |
| 0:14 | 每个像素是一个桶，函数被量化成分段的近似。 |
| 0:15 | 最小步长受限，Δx 无法继续变小。 |
| 0:16 | 最小步长是 1 个像素，我们失去了极限。 |
| 0:17 | 只能做割线估计，无法逼近真正的切线。 |
| 0:18 | 当微积分的'无限细分'撞上像素的'颗粒感'，导数还存在吗？ |
| 0:21 | 斜率在收敛，但像素世界有硬约束。 |
| 0:24 | 在数字图像里，Δx 最小就是 1 像素。 |
| 0:27 | 结论：需要新的方法，在像素里重建导数。 |
| 0:30 | 既然不能无限逼近，我们只能退而求其次：取相邻的点来估算。也就是'差分'。 |
| 0:32 | 但直接相减会带来误差。 |
| 0:33 | 前向与后向各有系统误差：奇偶阶项混在一起。 |
| 0:35 | 这里有一个数学上的巧合：如果我们同时看左边一点和右边一点（泰勒展开）... |
| 0:37 | 你会发现，它们的误差恰好方向相反。 |
| 0:39 | 如果我们把它们加起来……奇迹发生了，误差自我抵消了。 |
| 0:41 | 这就是中心差分，也是 Sobel 的一半灵魂。 |
| 0:43 | 三种差分：前向、后向、中心 —— 谁的误差更小？ |
| 0:45 | 中心差分利用两侧信息，误差阶更高。 |
| 0:47 | 中心差分最"冷"，误差最低。 |
| 0:48 | 结论：中心差分 = 低误差、对称采样。 |
| 0:50 | 现在我们有了两个工具：一个是平滑（用来对付噪点），一个是中心差分（用来计算斜率）。 |
| 0:52 | 直接微分会放大噪声。 |
| 0:53 | 先平滑，再微分：用 [1,2,1]^T 做低通，再用 [-1,0,1] 做高通。 |
| 0:55 | 平滑核滑过信号：窗口内的点被加权平均拉平。 |
| 0:56 | 平滑后，噪声被抑制，信号结构更清晰。 |
| 0:58 | Sobel 算子其实不是什么新发明，它只是把这两个动作，巧妙地打包进了一个 3x3 的小盒子里。 |
| 1:00 | 一手按住噪点，一手提取边缘。 |
| 1:02 | 卷积 = 滑动窗口的加权求和。看看 Sobel 如何工作。 |
| 1:04 | 窗口逐行扫描，每一步计算 G = 核 · 局部补丁。 |
| 1:05 | 卷积结果逐步填充：红=强边缘，蓝绿=弱。 |
| 1:06 | 尺度决定细节：小核抓细纹，大核抓粗轮廓。 |
| 1:08 | 3×3 抓细节，7×7 更平滑、边缘更粗。 |
| 1:09 | 融合多尺度：既留细节，也保轮廓。 |
| 1:10 | 把亮度映射为高度，图像变成 3D 地形。 |
| 1:12 | 用滑动窗口扫描：窗口颜色随梯度大小而变。 |
| 1:26 | 真实流程：原图 → 灰度 → Sobel X/Y → 梯度幅值 → 阈值。 |
| 1:27 | 调阈值：过低=噪声，过高=断裂。 |
| 1:29 | 看看现实画面：左侧原图，右侧边缘提取。 |
| 1:31 | Sobel 把结构凸显：道路边界、笔画、人脸轮廓、建筑窗格。 |
| 1:33 | 从连续导数到离散差分，从噪声到轮廓，我们看见了什么。 |
| 1:35 | 知行合一：数学理想 Δx→0，工程现实 pixel=1。 |

**总计：49 条文案，总时长约 1分37秒**

