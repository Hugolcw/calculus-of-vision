这是一个从“导演视角”切换回“首席技术官（CTO）视角”的关键步骤。既然我们已经确定了视觉体验的目标（色彩语义、物理质感、空间认知），在编写 Manim 代码时，我们需要通过具体的**代码架构**和**参数调优**来实现它们。

基于之前的反思，以下是在 `code.py` 编写过程中必须执行的 **工程级细节清单** ：

### 1. 全局配置与语义绑定 (Global Config & Semantics)

反思回顾： 我们提到了“一致性编码”。在代码中，这意味着杜绝硬编码（Hard-coding）。

代码细节：

* **建立常量池：** 在文件开头定义所有语义颜色。不要在 `play()` 里直接写 `RED` 或 `GREEN`。
  **Python**

  ```
  # config.py 或 脚本开头
  COLOR_DIFF = RED_C      # 语义：微分、变化、高频
  COLOR_SMOOTH = TEAL_C   # 语义：平滑、保持、低频
  COLOR_GHOST = GREY_B    # 语义：过去的影子、理想状态
  OPACITY_GHOST = 0.25    # 统一幽灵透明度
  ```
* **统一字体：** 为了符合北邮工科气质，数学公式建议使用 LaTeX 标准字体，说明文字建议使用更现代的无衬线字体（如 Manim 默认的）。

### 2. Scene 1：采样与“幽灵”特效 (Sampling & The Ghost)

反思回顾： 我们需要保留连续曲线作为背景，不能让它消失。

代码细节：

* **对象复制法：** 不要试图改变同一个对象的属性，而是创建副本。
  **Python**

  ```
  # 错误做法：直接变身
  # self.play(Transform(continuous_graph, discrete_stems)) 
  # 这样会导致形状插值混乱，视觉效果很脏

  # 正确做法：幽灵分离
  ghost_graph = continuous_graph.copy() # 创建替身
  self.add(ghost_graph) # 把替身加到场景里

  self.play(
      continuous_graph.animate.set_opacity(0), # 原身隐形（或直接变成柱子）
      ghost_graph.animate.set_stroke(width=1, opacity=OPACITY_GHOST), # 替身变成背景
      Create(discrete_stems) # 离散柱子生长出来
  )
  ```
* **对齐采样点：** `discrete_stems` 的 x 坐标必须严格对应 `np.linspace` 生成的点，确保柱子顶端完美落在 `ghost_graph` 的路径上，避免视觉错位。

### 3. Scene 2：泰勒公式的“微操” (Micro-management of LaTeX)

反思回顾： 分步揭示，手动对齐。

代码细节：

* **子串隔离 (Substring Isolation)：** 使用 `MathTex` 的分割功能，把每一个符号变成独立的可操作对象（Mobject）。
  **Python**

  ```
  # 将公式拆解为独立元素列表
  taylor_eq = MathTex(
      "f(x+1)", "\\approx", "f(x)", "+", "f'(x)", "+", "\\frac{1}{2}f''(x)"
  )
  # 这样你就可以单独索引：taylor_eq[2] 是 f(x)，taylor_eq[4] 是 f'(x)
  ```
* **颜色传递：** 当项被抵消时，先变色再消失。
  **Python**

  ```
  self.play(
      taylor_eq[2].animate.set_color(COLOR_DIFF), # 变红预警
      taylor_eq_minus[2].animate.set_color(COLOR_DIFF)
  )
  self.wait(0.5) # 关键停顿：让观众意识到它们是一对
  self.play(
      FadeOut(taylor_eq[2]), 
      FadeOut(taylor_eq_minus[2])
  )
  ```
* **引用对齐：** 使用 `VGroup.arrange()` 或者 `next_to()` 确保公式消去后，剩下的部分能自动靠拢，或者保持原位（取决于你想强调“空缺”还是“化简”）。建议保留空缺一瞬间，再合并。

### 4. Scene 4：性能优化与 3D 渲染 (Performance & 3D)

反思回顾： 防止渲染崩溃，降低空间认知的难度。

代码细节：

* **切片动画的坐标系转换：**

  * 先在 `NumberPlane` (2D) 上画出波形。
  * 然后使用 `ReplacementTransform` 将其转换到 `ThreeDScene` 的 `Surface` 的某一条边上。
* 暴力降采样 (Aggressive Downsampling)： 1
  这是最容易导致项目烂尾的技术坑。一定要在生成 Surface 之前处理数据。
  **Python**

  ```
  # 假设 raw_image 是读取的图片
  pixel_array = raw_image.get_pixel_array()

  # [关键] 切片操作：每 10 个像素取 1 个
  # 如果不切，1920x1080 的图会生成 200万个顶点，Manim 会直接卡死
  height_map = pixel_array[::10, ::10, 0] # 只取一个通道

  # 创建 Surface
  surface = Surface(
      lambda u, v: axes.c2p(u, v, height_map[int(u)][int(v)]),
      resolution=(width//10, height//10) # 分辨率要和数据匹配
  )
  ```
* **相机运镜 (Camera Moves)：**

  * 使用 `self.move_camera(phi=60*DEGREES, theta=-45*DEGREES)`。
  * **缓动函数：** 加上 `rate_func=smooth`，避免镜头突然甩动导致晕眩。

### 5. 开发工作流的细节 (Workflow Details)

**为了保证在 12月15日 **^2^ 前完工，编码时请遵循：

* 低画质预览： 渲染时始终使用 -ql (Quality Low) 标志进行调试。
  manim -pql scene.py SceneName
* **模块化测试：** 不要把所有代码写在一个 `def construct(self):` 里。
  **Python**

  ```
  def construct(self):
      self.setup_scene_1()
      self.transition_1_2()
      self.setup_scene_2()
      # ... 注释掉已经写好的部分，只渲染当前正在写的函数，节省时间
  ```
